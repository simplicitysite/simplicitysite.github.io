---
title: Building Antifragile Software with Microservices
layout: course
permalink: building_adaptable_software/
duration: 3 days
public: true
external: 
 - London, UK
 - 
   - 19/05/2014 - 21/05/2014
   - 13/08/2014 - 15/08/2014
   - 10/11/2014 - 12/11/2014
 - "<div style=\"text-align:center; margin-bottom: 1em;\"><p style=\"text-decoration: line-through;\">£1995</p>  <p style=\"font-size:1.3em;\">£1795 + VAT<br/>(Early bird, <strong>10% off</strong>)</p></div>"
 

sidebar: |
 <img src="/static/images/training/action/action2.jpg" style="" />
 <img src="/static/images/training/action/action4.jpg" style="" />

---
#Building Antifragile Software with Microservices

Ever experienced that moment where your heart sinks at the words "We just want you to make this one, small and trivial change…".

If you build software, change is an inevitable force in your life and your ability to react to change can be the difference between a killer product and a last-to-the-post flop.

Given that change and speed of software evolution is so critical, why is it that so much software becomes a millstone around yourself and your team's next, leading to you dreading the next inevitable change that's needed? For over 10 years, focus has been consistently applied to helping us work in a more agile and adaptable fashion, with far less focus on how to create software that thrives in an agile environment.

This hands-on, extremely practical course teaches you the latest techniques you can apply today to your architecture, design and code to build software that doesn't fear change. This course will teach you how to build software that adapts as fast as your business and requirements do.

## Audience

Any developer with some experience of, ideally, Java, and wants to build software that adapts as fast as their business does.

### In this course you will learn how to

* Understand Change: Manage evolution from a component, module and system perspective.
* Understand Complexity: Identify the causes of complexity in your architecture, design and code and the affect it has on dealing with change.
* Organise for Change: Organise your architecture, design and code for clarity and change.
* Clean Design and Architecture: Architect, design and build components that embrace change
* Reduce Inter and Intra System Coupling: Identify and Manage accidental coupling between components, modules and systems.
* Functional Programming for Humans: Apply practical functional programming concepts regardless of your language or framework choice.
* Apply Events: Apply Event-Driven Architectural patterns to increase de-coupling.
* Introduce new languages: When and How to apply the right language to simplify your code for a given component.

## Programme

### Topics
* Understanding Change
	* Pushing the Elephant
	* Real Agility requires Agile Software too.
	* Maximising Human Comprehension
	* Principle of Least Surprise
	* Overproduction
* Understanding Complexity
	* A continuum
	* Organise, Reduce, Encapsulate
	* Doing the Simplest Thing
* Adaptable Architecture
	* Organising for Clarity and Change
	* Clean Architecture
	* The Hexagonal View of your Application
	* The Life Preserver Pattern and Tool
* Adaptable Design
	* Designing Simple Components
	* Reducing to the functionality that matters
	* Organising, Reducing and Hiding Side-Effects
	* Designing system, module and component APIs that embrace change
	* Types of Coupling
	* How and When to Overcome Coupling
	* Interactions and Composition over Inheritance
	* Polymorphism a la carte
	* Characteristics of Supple Design
	* Pipes, Filters and Events patterns
* Adaptable Code - Functional Programming A La Carte, for Humans
	* Components as Functions
	* Maximising Unit Testing by Extracting Side Effects
	* Reducing Ordering Complexity
	* De-coupling through Events and CQRS
	* Inspect what's happening at runtime with Complex Event Processing
	* Implicit and Explicit data schema
	* When and How to implement Postel's Law
	* Why and How Monads help
	* Working with data documents (Maps/Lists) with Combinator Functions 
	* Options and Protocols
	* Factories and Avoiding Coupling through Construction and Configuration
	* How to choose between implementation approaches: Libraries, Frameworks, Languages